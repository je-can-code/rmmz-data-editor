name: Build & Release

# Defines the trigger for when to execute this workflow.
on:
  # Arbitrary decisions that will likely be changed once a proper workflow is ready and branching strategy decided.
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

env:
  DEBUG: false

jobs:
  # step 1: build, test, and upload the artifact if successful.
  ci:
    # I choose ubuntu mostly because it loads and executes the steps in like 20% the time windows-latest did.
    runs-on: ubuntu-latest
    
    # The environment variables that are used throughout this step.
    env:
      SOLUTION_PATH: ./J-EmZee.sln
      APP_PROJECT_PATH: ./src/Dashboard/Dashboard.csproj
      TEST_PROJECT_PATH: ./test/Rmmz.Data/Rmmz.Data.Tests.csproj
      ARTIFACT_PATH: ./out
      ARTIFACT_NAME: artifact
      
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
    # The custom output variables available 
    outputs:
      ARTIFACT_PATH: ${{ env.ARTIFACT_PATH }}
      ARTIFACT_NAME: ${{ env.ARTIFACT_NAME }}
    
    steps:
      # Download your repository to the runner.
      - name: Checkout
        uses: actions/checkout@v3

      # Install .NET onto the runner.
      - name: Install .NET
        uses: actions/setup-dotnet@v3
        with:
          global-json-file: global.json
          # cache: true

      # Restore all dependencies to the solution.
      - name: Restore dependencies
        run: dotnet restore 

      # Build all projects of the solution (without implicit restore).
      - name: Build solution
        run: dotnet build --no-restore

      # Run all tests of the solution (without implicit restore or build).
      - name: Run tests
        run: dotnet test --no-restore --no-build
      
      # Create the output directory ahead of publishing- can't publish to a place that doesn't exist!.
      - name: Make output directory
        run: mkdir $ARTIFACT_PATH
      
      # Compile the app with an arbitrary selection of options.
      # The selection from top to bottom: the path to the main project, the output path, the configuration type,
      # the runtime target, and the last three together enforce "1-file publishing" (plus the debug files).
      - name: Compile app
        run: >-
          dotnet publish $APP_PROJECT_PATH
          -o $ARTIFACT_PATH
          -c Release
          -r win-x64
          --self-contained true
          -p:PublishSingleFile=true
          -p:IncludeNativeLibrariesForSelfExtract=true
      
      # Zip up the app output into a regular .zip archive, so all files are together and compressed.
      - name: Zip app
        run: zip -r $ARTIFACT_NAME.zip $ARTIFACT_PATH

      # Some debug logging for what everything looks like before uploading.
      - name: 'DEBUG: Log current and output directories'
        if: ${{ env.DEBUG }}
        run: ls && ls $ARTIFACT_PATH

      # Expose the archive as an artifact for download or use in further jobs.
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: build-artifacts
          path: ${{ env.ARTIFACT_NAME }}.zip
          retention-days: 2

# step 2: publish the app as a release.
  cd:
    # if: true == false
    needs:
      - ci
    runs-on: ubuntu-latest
    
    # The environment variables that are used throughout this step.
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      ARTIFACT_PATH: ${{ needs.ci.outputs.ARTIFACT_PATH }}
      ARTIFACT_NAME: ${{ needs.ci.outputs.ARTIFACT_NAME }}
    
    steps:
      # Download the artifacts from the previous step.
      - name: Download the artifact  
        uses: actions/download-artifact@v3
        with:
          name: build-artifacts
          path: ./

      # Some debug logging for what everything looks like before doing release things.
      - name: 'DEBUG: Log directories'
        if: ${{ env.DEBUG }}
        run: ls

      # Initialize a new release with the designated data points.
      - name: Create the release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: 'test-tag-name'
          release_name: 'test-release-name'
          draft: true
          prerelease: true
      
      # Upload the files we want as a part of the release.
      - name: Upload assets to the release
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./
          asset_name: ${{ env.ARTIFACT_NAME }}
          asset_content_type: application/zip

      # Upload the files we want as a part of the release.
      - name: Publish the Release (maybe we shouldn't do this yet)
        if: true == false
        uses: eregon/publish-release@v1
        with:
          release_id: ${{ steps.create_release.outputs.id }}
